////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "mmap-manager.h"

#include <cassert>

#include <cstring>

#include <errno.h>

#include <stdlib.h>

#include <stdio.h>

#include <string>

#include <inttypes.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MemoryMapManager::MemoryMapManager ()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

MemoryMapManager::~MemoryMapManager ()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

size_t MemoryMapManager::ParseUnixProcessMapsFile (const char *filename)
{
  assert (filename != NULL);

  m_regions.clear ();

  FILE *mapsFile = fopen (filename, "r");

  if (!mapsFile)
  {
    fprintf (stderr, "Failed to open process maps file (%s). %s.\n", filename, strerror (errno));

    fflush (stderr);

    errno = 0;

    return 0;
  }

  int result = 0;

  while (true)
  {
    MemoryMapRegion mapData;

    result = fscanf (mapsFile, "%llx%llx %4s %llx %*x:%*x %ld", &mapData.start, &mapData.end, mapData.permissions, &mapData.offset, &mapData.inode);

    if ((result <= 0) || (result == EOF))
    {
      break;
    }

    // 
    // The length and/or presence of a map region name is rather inconsistent, so we need to parse carefully.
    // TODO: Reading 1-byte at a time is lame - good candidate for a refactor.
    // 

    char buffer [1024];

    size_t i = 0;

    bool validEntry = true;

    int result = F_OK;

    do
    {
      result = fread (&buffer [i], 1, 1, mapsFile);

      if ((buffer [i] == '\0')
        || (buffer [i] == '\n'))
      {
        break;
      }
    }
    while (++i && (result >= 0));

    buffer [i - 1] = '\0';

    const char *pathname = buffer;

    while (*pathname == ' ')
    {
      pathname += 1;
    }

    size_t pathnameLen = strlen (pathname);

    if ((pathnameLen == 0)
      || (strchr (pathname, ' '))
    #if 0
      &&(pathnameLen < 7) // at very least must be libX.so
      && ((strncmp (pathname + (pathnameLen -  3), ".so", 3) != 0)
          || (strncmp (pathname + (pathnameLen - 4), ".dex", 4) != 0)
          || (strncmp (pathname + (pathnameLen - 4), ".oat", 4) != 0))
    #endif
      )
    {
      validEntry = false;
    }

    if (validEntry)
    {
      strncpy (mapData.pathname, pathname, 128);

      m_regions.push_back (mapData);
    }

    result = feof (mapsFile);

    if ((result != 0) || (result == EOF))
    {
      break;
    }
  }

  fclose (mapsFile);

  return m_regions.size ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const MemoryMapRegion *MemoryMapManager::FindMapForAddress (uint64_t address) const
{
  for (size_t i = 0; i < m_regions.size (); ++i)
  {
    const MemoryMapRegion *region = &m_regions [i];

    if (address > region->end)
    {
      continue;
    }
    else if (address < region->start)
    {
      continue;
    }
    else if (address >= region->start)
    {
      return region;
    }
  }

  return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool MemoryMapManager::PopulateJsonObject (JsonNode &node) const
{
  if (!node.IsObject ())
  {
    assert (node.IsObject ());

    return false;
  }

  kvr::value *array = node.GetImpl ()->insert_array ("frames");

  JsonNodeKvr arrayNode (*array);

  return PopulateJsonArray (arrayNode);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool MemoryMapManager::PopulateJsonArray (JsonNode &node) const
{
  if (!node.IsArray ())
  {
    assert (node.IsArray ());

    return false;
  }

  std::vector <MemoryMapRegion>::const_iterator it = m_regions.begin ();

  while (it != m_regions.end ())
  {
    const MemoryMapRegion &map = *it;

    kvr::value *mapNode = node.GetImpl()->push_map ();

    char buffer [32];

    snprintf (buffer, 32, "0x%" PRIx64, map.start);

    mapNode->insert ("start", buffer);

    snprintf (buffer, 32, "0x%" PRIx64, map.end);

    mapNode->insert ("end", buffer);

    snprintf (buffer, 32, "0x%" PRIx64, map.offset);

    mapNode->insert ("offset", buffer);

    mapNode->insert ("permissions", map.permissions);

    mapNode->insert ("name", map.pathname);

    it++;
  }

  return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
