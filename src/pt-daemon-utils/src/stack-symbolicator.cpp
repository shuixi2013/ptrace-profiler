////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stack-symbolicator.h"

#include "addr2line.h"

#include <cassert>

#include <cstring>

#include <errno.h>

#include <stdlib.h>

#include <stdio.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

StackSymbolicator::StackSymbolicator (const MemoryMapManager &mmapManager)
  : m_mmapManager (mmapManager)
  , m_currentToken (0)
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StackSymbolicator::Preprocess (const StackCorkscrew &corkscrew)
{
  const size_t stackDepth = corkscrew.GetDepth ();

  for (size_t i = 0; i < stackDepth; ++i)
  {
    StackFrame frame = corkscrew.m_frames [i];

    // 
    // Find a token for this frame's PC address.
    // Tokens are used for finding duplicate addresses, reducing duplicate symbolication requests.
    // 

    uint64_t token = 0;

    {
      auto it = m_tokensByPc.find (frame.m_pc);

      if (it != m_tokensByPc.end ())
      {
        token = it->second;
      }
      else
      {
        token = ++m_currentToken;

        std::pair <uint64_t, StackToken> entry (frame.m_pc, token);

        m_tokensByPc.insert (entry);
      }
    }

    // 
    // Check for previously mapped/symbolicated results for this token. 
    // Otherwise, insert a new symbolication entry.
    // 

    {
      auto it = m_locationsByToken.find (token);

      if (it != m_locationsByToken.end ())
      {
        const std::string &function = it->second;

        strncpy (frame.m_function, function.c_str (), sizeof (frame.m_function));

        frame.m_function [sizeof (frame.m_function) - 1] = '\0';
      }
      else
      {
        const MemoryMapRegion *map = m_mmapManager.FindMapForAddress (frame.m_pc);

        if (map)
        {
          const uint64_t offset = (frame.m_pc - map->start) + map->offset; // TODO: do something with map->offset too?

          snprintf (frame.m_function, sizeof (frame.m_function), "%s!0x%llx", map->pathname, offset);
        }
        else
        {
          snprintf (frame.m_function, sizeof (frame.m_function), "%s!0x%llx", "??", frame.m_pc);
        }

        std::string function = frame.m_function;

        std::pair <uint32_t, std::string> entry (token, function);

        m_locationsByToken.insert (entry);
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void StackSymbolicator::Symbolicate (Addr2Line &addr2line)
{
  auto it = m_locationsByToken.begin ();

  while (it != m_locationsByToken.end ())
  {
    size_t pos = it->second.find ('!');

    if (pos != std::string::npos)
    {
      std::string lib = it->second.substr (0, pos);

      std::string address = it->second.substr (pos + 1);

      addr2line.Symbolicate (lib, address, &it->second);
    }

    it++;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
