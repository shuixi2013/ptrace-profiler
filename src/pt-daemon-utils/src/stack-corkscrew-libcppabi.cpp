////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stack-corkscrew.h"

#include <cassert>

#include <unwind.h>

#include <dlfcn.h>

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct UnwindHandlerArgs
{
  pid_t ppid;

  pid_t tid;

  size_t currentDepth;

  size_t ignoreDepth;

  size_t maxDepth;

  StackCorkscrewLibcppabi *corkscrew;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static _Unwind_Reason_Code UnwindHandler (struct _Unwind_Context* context, void* ref)
{
  UnwindHandlerArgs *args = (UnwindHandlerArgs*) ref;

  if (args->currentDepth < args->ignoreDepth)
  {
    return _URC_NO_REASON; // Skip ignored frames.
  }

  StackFrame frame;

  frame.m_pc = _Unwind_GetIP (context);

  frame.m_sp = _Unwind_GetCFA (context);

  frame.m_level = args->currentDepth;

  strncpy (frame.m_function, "??", 128);

#if 1

  struct dl_info dyldInfo;

  if (dladdr ((void*)frame.m_pc, &dyldInfo))
  {
    snprintf (frame.m_function, 128, "%s", dyldInfo.dli_sname);
  }

#endif

  args->corkscrew->PushFrame (frame);

  if (++args->currentDepth >= args->maxDepth)
  {
    return _URC_NORMAL_STOP;
  }

  return _URC_NO_REASON;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

size_t StackCorkscrewLibcppabi::Unwind (pid_t ppid, pid_t tid, size_t ignoreDepth, size_t maxDepth)
{
  assert (ppid > 0);

  assert (tid >= ppid);

  m_frames.clear ();

  if (maxDepth == 0)
  {
    return 0;
  }

  UnwindHandlerArgs args;

  args.ppid = ppid;

  args.tid = tid;

  args.currentDepth = 0;

  args.ignoreDepth = ignoreDepth;

  args.maxDepth = maxDepth;

  args.corkscrew = this;

  _Unwind_Backtrace (UnwindHandler, &args);

  return m_frames.size ();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
